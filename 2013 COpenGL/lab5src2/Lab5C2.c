/*
 * Lab5C2.c
 *  Basic program with texture mapping
 *  Maps textures generated by code to shapes.
 *  In this example, 1-d and 2-d textures are pixel maps and mapped
 *   to colored objects to see the interaction between "intrinsic" color
 *   and the mapped texture.
 *
 *  Created on: Jun 17, 2013
 *      Author: Anthony Varghese
 */
#include <stdio.h>
#include <math.h>
#include <string.h>

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>

int   main_window;

GLfloat rotation_angle = 0.0;

// camera position:
GLfloat camera_x =   20.0f;
GLfloat camera_y =    0.0f;
GLfloat camera_z =  300.0f;

// camera aim:
GLfloat camera_aim_x =   0.0f;
GLfloat camera_aim_y =   0.0f;
GLfloat camera_aim_z =   0.0f;

// viewing area
GLfloat view_area_width  = 400.0f;
GLfloat view_area_height = 300.0;

// cube size
GLfloat cubesize = 10.0;

/* bitmap -- bitmaps are specified "upside-down"
 *	bottom to top. i.e.  bit 7 of the first byte corresponds to bottom-left corner.
 */
GLubyte rasters[24] = { 0xC0, 0x00,	0xC0, 0x00,		0xC0, 0x00, 0xC0, 0x00,
							0xC0, 0x00, 0xFF, 0x00,		0xFF, 0x00, 0xC0, 0x00,
							0xC0, 0x00, 0xC0, 0x00,		0xFF, 0x00, 0xFF, 0x00  };

#define numTextures  2
GLuint texture_objects[numTextures];

// texture 1 -- 1-D texture
#define oneDim_bytes     4
#define oneDim_length  256
GLubyte oneDimage[oneDim_length][oneDim_bytes];

#define twoDim_bytes   4
#define imagewidth    32
#define imageheight   32
GLubyte   teximage[imageheight][imagewidth][twoDim_bytes];

const GLint detaillevel = 0;

void printerror() {
	GLenum error = glGetError();
	if (error == GL_NO_ERROR)
	   return;
	printf("	Error detected: %s\n ", gluErrorString( error ) );
}

void drawString (GLfloat x, GLfloat y, GLfloat z, char* s, int length) {
   glRasterPos3f(x, y, z);
   for (size_t i = 0; i < length; i++)
      glutBitmapCharacter( GLUT_BITMAP_TIMES_ROMAN_10, s[i] );
}

void setupOneDImage() {
	float factor = 256.0/oneDim_length;
	for (int i=0; i<oneDim_length; i++) {
		int k = oneDim_length -i;
		if (i > oneDim_length/2)
			k = i;
		oneDimage[i][0] = (GLubyte) k*factor  ; // red
		oneDimage[i][1] = (GLubyte) k*factor/2; // green
		oneDimage[i][2] = (GLubyte) k*factor/4; // blue
		oneDimage[i][3] = (oneDimage[i][0] + oneDimage[i][1] +
								oneDimage[i][2]) / 3; // opacity
	}
}
void setupTwoDImage(){
	for (int i=0; i<imageheight; i++)
		for (int j=0; j<imagewidth; j++) {
			teximage[i][j][0] = (GLubyte) i*8  + j*2; // red
			teximage[i][j][1] = (GLubyte) i*8  + j*8; // green
			teximage[i][j][2] = (GLubyte) i*2  + j*8; // blue
			teximage[i][j][3] = (teximage[i][j][0] + teximage[i][j][1] + teximage[i][j][2]) / 3; // opacity
		}
}

void draw_axes(){
   glColor3f (.2f, 1.0f, .0f);
   glBegin (GL_LINES);
	glVertex3f (-view_area_width/2, 0, 0);
	glVertex3f (view_area_width/2, 0, 0);
	glVertex3f (0, -view_area_height/2, 0);
	glVertex3f (0, view_area_height/2, 0);
	glVertex3f (0, 0, -view_area_width/2);
	glVertex3f (0, 0, view_area_width/2);
   glEnd ();
}

void display(void) {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
	glPushMatrix();

	glRotatef( rotation_angle, 0.0, 1.0, 0.0 );

	printerror();

	glEnable( GL_TEXTURE_1D );
	/* Choices for texture environment are:
	 *  GL_MODULATE == apply lighting and coloring to texture
	 *  GL_DECAL    == lighting and coloring will not affect texture
	 *
	 */
	glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );
    glColor3f (0.7f, 0.7f, 0.7f);
	glBegin( GL_POLYGON );
	    // Texture coordinates associate a location in the texture image with
	    //  a vertex in a polygon
		glTexCoord1f( 0.0f ); glVertex3f( -170.0f,    0.0f, 0.0f );
		glTexCoord1f( 1.0f ); glVertex3f( -150.0f,  100.0f, 0.0f );
		glTexCoord1f( 1.0f ); glVertex3f(  -10.0f,   90.0f, 0.0f );
		glTexCoord1f( 0.0f ); glVertex3f(  -10.0f,   10.0f, 0.0f );
	glEnd();
	glDisable( GL_TEXTURE_1D );

	printerror();

	glEnable( GL_TEXTURE_2D );
	glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL );
    glColor3f (1.0f, 0.0f, 0.0f);
	glBegin( GL_QUADS );
	    // Texture coordinates associate a location in the texture image with
	    //  a vertex in a polygon
		glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -170.0f, -140.0f, 0.0f );
		glTexCoord2f( 0.0f, 1.0f ); glVertex3f(  -20.0f, -130.0f, 0.0f );
		glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  -10.0f,  -10.0f, 0.0f );
		glTexCoord2f( 1.0f, 0.0f ); glVertex3f( -160.0f,  -10.0f, 0.0f );

		glTexCoord2f( 0.0f, 0.0f ); glVertex3f(  60.0f, -100.0f,   0.0f );
		glTexCoord2f( 0.0f, 1.0f ); glVertex3f(  60.0f,   60.0f,   0.0f );
		glTexCoord2f( 1.0f, 1.0f ); glVertex3f( 150.0f,   60.0f, -20.0f );
		glTexCoord2f( 1.0f, 0.0f ); glVertex3f( 150.0f, -100.0f, -20.0f );
	glEnd();
	glDisable( GL_TEXTURE_2D );

	printerror();

	// Enable material color proprties of objects
/*	glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
	GLfloat specular_reflectivity[] =  { 1.0f, 1.0f, 1.0f, 1.0f };
	glMaterialfv(GL_FRONT, GL_SPECULAR,specular_reflectivity);
	glMateriali(GL_FRONT,GL_SHININESS,128); // shiny!

	printerror();
*/
	// draw axes
	draw_axes ();
	glColor3f (1.0f, 1.0f, 1.0f);
	char* esc_string = "Hit esc to quit";
	drawString (-view_area_width/2, view_area_height/2.5, 0, esc_string, strlen(esc_string) );

	printerror();

	// Set the current raster position -- uses the programmer's "scene" coordinates.
	glRasterPos2i( 20, 20 );
	// draw the bitmap and move to the next position
	//      width height   Origin      Increments for next position     bitmap
	glBitmap( 10,  12,     0.0f, 0.0f, 20.0f, 0.0f,                     rasters );
	glBitmap( 10,  12,     0.0f, 0.0f, 20.0f, 20.0f,                    rasters );
	glBitmap( 10,  12,     0.0f, 0.0f,  0.0f, 20.0f,                    rasters );

	printerror();

	// Draw the texture image as a pixel array
	glRasterPos2i(0,0);
	glDrawPixels( imagewidth, imageheight, GL_RGBA, GL_UNSIGNED_BYTE, teximage );

	printerror();

	glFlush ();
	glPopMatrix();
}

void reshape(GLsizei width, GLsizei height) {
	if (height == 0) height = 1;
	const float w = view_area_width  = width;
	const float h = view_area_height = height;
	float aspectratio = w / h;

	glViewport(0, 0, width, height);

	glMatrixMode( GL_PROJECTION );
	glLoadIdentity();
	gluPerspective( 60.0f, aspectratio, 1.0f, 1000.0f );
	//    glOrtho( -w/2, w/2, -h/2, h/2, -w/2, h/2 );

	glMatrixMode( GL_MODELVIEW );
	glLoadIdentity();
	// set "camera" position
	gluLookAt( /* camera at:   */ camera_x,     camera_y,     camera_z,
	           /* aim towards: */ camera_aim_x, camera_aim_y, camera_aim_z,
	           /* up is:       */  0.f,         1.f,          0.f );

}

void mouse (int button, int state, int x, int y) {
   static int i=1;
   if (state == GLUT_DOWN){
	   if (button == GLUT_LEFT_BUTTON)
			i++;
	   else
		   if (button == GLUT_RIGHT_BUTTON)
			   (i <= 1) ?	 i=1 :	 i--;
   }
   glPixelZoom( (GLfloat)i, (GLfloat) i );
   glutPostRedisplay();
}

void key(unsigned char k, int x, int y) {
	switch (k) {
		case 27 /* ESC key */: exit(0);
	}
}

void idle( void ) {
   rotation_angle += 1.0f;
   glutPostRedisplay();
}
void texture_queries() {
	int maxTexsize;
	glGetIntegerv( GL_MAX_TEXTURE_SIZE, &maxTexsize);
	printf( " Largest width or height of a texture %d\n", maxTexsize );

	// 1-D textures
	glTexImage1D ( GL_PROXY_TEXTURE_1D, detaillevel, oneDim_bytes, oneDim_length, 0, GL_RGBA,
					GL_UNSIGNED_BYTE, NULL );
	int avail_width, avail_internal_format, avail_red_size, avail_lum_size;
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, detaillevel, GL_TEXTURE_WIDTH,			&avail_width);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, detaillevel, GL_TEXTURE_INTERNAL_FORMAT, &avail_internal_format);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, detaillevel, GL_TEXTURE_RED_SIZE,		&avail_red_size);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_1D, detaillevel, GL_TEXTURE_LUMINANCE_SIZE, &avail_lum_size);
	printf( "  1-D Texture available sizes:\n" );
	printf( "    width:           %d\n", avail_width );
	printf( "    internal format: %d\n", avail_internal_format );
	printf( "    color (red):     %d\n", avail_red_size );
	printf( "    luminance:       %d\n", avail_lum_size );

	// 2-D textures
	glTexImage2D ( GL_PROXY_TEXTURE_2D, detaillevel, twoDim_bytes, imagewidth, imageheight, 0, GL_RGBA,
					GL_UNSIGNED_BYTE, NULL );
	int avail_height;
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, detaillevel, GL_TEXTURE_WIDTH,			&avail_width);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, detaillevel, GL_TEXTURE_HEIGHT,			&avail_height);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, detaillevel, GL_TEXTURE_INTERNAL_FORMAT, &avail_internal_format);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, detaillevel, GL_TEXTURE_RED_SIZE,		&avail_red_size);
	glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, detaillevel, GL_TEXTURE_LUMINANCE_SIZE, &avail_lum_size);
	printf( "  2-D Texture available sizes:\n" );
	printf( "    width:           %d\n", avail_width );
	printf( "    height:          %d\n", avail_height );
	printf( "    internal format: %d\n", avail_internal_format );
	printf( "    color (red):     %d\n", avail_red_size );
	printf( "    luminance:       %d\n", avail_lum_size );

	// 3-D textures
	/* Not available in VC++ */
	const int image_depth = 32;
	glTexImage3D ( GL_PROXY_TEXTURE_3D, detaillevel, twoDim_bytes, imagewidth, imageheight, image_depth, 0, GL_RGBA,
					GL_UNSIGNED_BYTE, teximage );
	int avail_depth;
	glGetTexLevelParameteriv(GL_TEXTURE_3D, detaillevel, GL_TEXTURE_WIDTH,			&avail_width);
	glGetTexLevelParameteriv(GL_TEXTURE_3D, detaillevel, GL_TEXTURE_HEIGHT,			&avail_height);
	glGetTexLevelParameteriv(GL_TEXTURE_3D, detaillevel, GL_TEXTURE_DEPTH,			&avail_depth);
	glGetTexLevelParameteriv(GL_TEXTURE_3D, detaillevel, GL_TEXTURE_INTERNAL_FORMAT, &avail_internal_format);
	glGetTexLevelParameteriv(GL_TEXTURE_3D, detaillevel, GL_TEXTURE_RED_SIZE,		&avail_red_size);
	glGetTexLevelParameteriv(GL_TEXTURE_3D, detaillevel, GL_TEXTURE_LUMINANCE_SIZE, &avail_lum_size);
	printf( "  3-D Texture available sizes:\n" );
	printf( "    width:           %d\n", avail_width );
	printf( "    height:          %d\n", avail_height );
	printf( "    depth:           %d\n", avail_depth );
	printf( "    internal format: %d\n", avail_internal_format );
	printf( "    color (red):     %d\n", avail_red_size );
	printf( "    luminance:       %d\n", avail_lum_size );
}


void init(void) {
	glClearColor (0.0f, 0.0f, 0.0f, 0.0f);
	// enable depth
	glEnable(GL_DEPTH_TEST);
	glDisable( GL_DITHER );

	// Set up textures
	texture_queries();

	glShadeModel( GL_FLAT );
	setupOneDImage();
	setupTwoDImage();
	glPixelStorei( GL_UNPACK_ALIGNMENT, 1 ); // byte alignment

	printerror();

	// Generate textures
	glGenTextures(numTextures, texture_objects );

	//  Define a 1-d texture
	glBindTexture( GL_TEXTURE_1D, texture_objects[0] );
	printf( " texture object 1 is %d\n", texture_objects[0] );

	// _S is the x direction of the texture image
	glTexParameteri( GL_TEXTURE_1D, GL_TEXTURE_WRAP_S,     GL_REPEAT  );
	glTexParameteri( GL_TEXTURE_1D, GL_TEXTURE_WRAP_T,     GL_REPEAT  );
	glTexParameteri( GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
	glTexParameteri( GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
	/* glTexImage1D loads the texture to the graphics hard/software memory
	 * Parameters:
	 *   target - GL_TEXTURE_1D.
     *   level  - level of detail number
	 *   format - internal format: # of color components; 3 == RGB, 4 == RGBA
     *   length - of texture image; must be a power of two
	 *   border - of texture image; must be 0 or 1
	 *   format - texture image data format; GL_RGB or GL_RGBA
     *   type   - data type; will this work in Java?
	 *   teximage - pointer to texture image data; data can be discarded after this call
	 */
	glTexImage1D ( GL_TEXTURE_1D, detaillevel, oneDim_bytes, oneDim_length, 0, GL_RGBA,
					GL_UNSIGNED_BYTE, oneDimage );
	printerror();


	//  Define a 2-d texture
	glBindTexture( GL_TEXTURE_2D, texture_objects[1] );
	printf( " texture object 2 is ", texture_objects[1] );

	// _S is the x direction of the texture image
	// _T is the y direction of the texture image
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_REPEAT  );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_REPEAT  );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
	/* glTexImage2D loads the texture to the graphics hard/software memory
	 * Parameters:
	 *   target - GL_TEXTURE_2D
     *   level  - level of detail number
	 *   format - internal format: # of color components; 3 == RGB, 4 == RGBA
     *   width
	 *   height - of texture image; must be a power of two
	 *   border - of texture image; must be 0 or 1
	 *   format - texture image data format; GL_RGB or GL_RGBA
     *   type   - data type; will this work in Java?
	 *   teximage - pointer to texture image data; data can be discarded after this call
	 */
	glTexImage2D ( GL_TEXTURE_2D, detaillevel, twoDim_bytes, imagewidth, imageheight, 0, GL_RGBA,
					GL_UNSIGNED_BYTE, teximage );
	printerror();
}

void setupLighting() {
	glEnable( GL_LIGHTING );
	glEnable( GL_LIGHT0   );
	glEnable( GL_LIGHT1   );
}


int main (int argc, char** argv)  {
	glutInit(&argc, argv);

	glutInitWindowPosition( 100, 100 );
	glutInitWindowSize( view_area_width, view_area_height );

	glutInitDisplayMode( GLUT_RGB | GLUT_SINGLE  | GLUT_DEPTH );
	main_window = glutCreateWindow( "Texture mapping" );

	init();
	glutReshapeFunc( reshape );
	glutDisplayFunc( display );
	glutKeyboardFunc( key );
	glutMouseFunc ( mouse );
    //glutIdleFunc( idle );
	//setup lighting
	//setupLighting ();

	glutMainLoop();
	return 0;
}
